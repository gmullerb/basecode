//  Copyright (c) 2018 Gonzalo MÃ¼ller Bravo.
//  Licensed under the MIT License (MIT), see LICENSE.txt

import javax.inject.Inject

import org.gradle.tooling.BuildLauncher
import org.gradle.tooling.GradleConnector

class ConcurrentTask extends DefaultTask {
  private final WorkerExecutor workerExecutor
  private final Class concurrentClass
  public String projectDir
  public String task
  public boolean showOutput = false
  public boolean showError = false
  public String outputFilePath = ''
  public String errorFilePath = ''
  public Object[] extraParams

  ConcurrentTask(final WorkerExecutor workerExecutor, final Class concurrentClass) {
    this.workerExecutor = workerExecutor
    this.concurrentClass = concurrentClass
  }

  @TaskAction
  void run() {
    workerExecutor.submit(concurrentClass) { config ->
      config.isolationMode = IsolationMode.PROCESS
      if (extraParams != null) {
        config.params projectDir, task, showOutput, showError, outputFilePath, errorFilePath, extraParams
      } else {
        config.params projectDir, task, showOutput, showError, outputFilePath, errorFilePath
      }
    }
  }
}

class SharedOutputStream extends OutputStream {
  private final Collection<OutputStream> streams

  SharedOutputStream(final Collection<OutputStream> streams) {
    if (streams == null) {
      throw new NullPointerException()
    }
    if (streams.any { it == null }) {
      throw new NullPointerException()
    }
    this.streams = Collections.unmodifiableCollection(streams)
  }

  void close() {
    streams.each { it.close() }
  }
  void flush() {
    streams.each { it.flush() }
  }
  void write(final byte[] b) {
    streams.each { it.write(b) }
  }
  void write(final byte[] b, final int off, final int len) {
    streams.each { it.write(b, off, len) }
  }
  void write(final int b) {
    streams.each { it.write(b) }
  }
}

abstract class ConcurrentTaskUnitOfWork implements Runnable {
  private final String projectDir
  private final String task
  private final String outputFilePath
  private final String errorFilePath
  private final boolean showOutput
  private final boolean showError
  private OutputStream outputStreams
  private OutputStream printStream
  private OutputStream errorStreams

  protected ConcurrentTaskUnitOfWork(final String projectDir, final String task, final boolean showOutput, final boolean showError,
    final String outputFilePath, final String errorFilePath) {
    this.projectDir = projectDir
    this.task = task
    this.showOutput = showOutput
    this.showError = showError
    this.outputFilePath = outputFilePath == null || outputFilePath.isEmpty() ?  null : outputFilePath
    this.errorFilePath = errorFilePath == null || errorFilePath.isEmpty() ?  null : errorFilePath
  }

  private OutputStream defineStream(final boolean show, final OutputStream stream, final String path) {
    final Collection<OutputStream> outputs = []
    if (show) {
      outputs.add(stream)
    }
    if (path != null) {
      outputs.add(new FileOutputStream(path))
    }
    outputs.isEmpty() ? null : new SharedOutputStream(outputs)
  }

  protected final void arrangeStreams() {
    outputStreams = defineStream(showOutput, System.out, outputFilePath)
    printStream = outputStreams != null ? new PrintStream(outputStreams) : null
    errorStreams = defineStream(showError, System.err, errorFilePath)
  }

  protected final void closeStreams() {
    outputStreams?.close()
    printStream?.close()
    errorStreams?.close()
  }

  protected final GradleConnector createNewConnetion() {
    GradleConnector.newConnector()
          .forProjectDirectory(new File(projectDir))
          .connect()
  }

  protected final BuildLauncher buildLauncher(final GradleConnector connection) {
    final launcher = connection.newBuild().forTasks(task)
    if (outputStreams != null) {
      launcher.standardOutput = outputStreams
    }
    if (errorStreams != null) {
      launcher.standardError = errorStreams
    }
    launcher
  }

  protected final void output(final String text) {
    if (outputStreams != null) {
      printStream.println(text)
    }
  }
}

class ScheduledEndlessTaskUnitOfWork extends ConcurrentTaskUnitOfWork {
  private final int scheduledTime
  private final boolean showRun

  @Inject
  ScheduledEndlessTaskUnitOfWork(final String projectDir, final String task, final boolean showOutput, final boolean showError,
    final String outputFilePath, final String errorFilePath, final Object[] extraParams) {
    super(projectDir, task, showOutput, showError, outputFilePath, errorFilePath)
    this.scheduledTime = extraParams[0]
    this.showRun = extraParams[1]
  }

  @Override
  void run() {
    arrangeStreams()
    try {
      int runNumber = 0
      while (true) {
        final connection = createNewConnetion()
        try {
          Thread.sleep(scheduledTime)
          buildLauncher(connection).run()
          if (showRun) {
            output("Run:${++runNumber} ${Instant.now()}")
          }
        } finally {
          connection.close()
        }
      }
    } finally {
      closeStreams()
    }
  }
}

class ScheduledEndlessTask extends ConcurrentTask {
  public int scheduledTime = 1000
  public boolean showRun = true

  @Inject
  ScheduledEndlessTask(final WorkerExecutor workerExecutor) {
    super(workerExecutor, ScheduledEndlessTaskUnitOfWork)
    extraParams = [scheduledTime, showRun]
  }
}

class SimultaneousTaskUnitOfWork extends ConcurrentTaskUnitOfWork {
  @Inject
  SimultaneousTaskUnitOfWork(final String projectDir, final String task, final boolean showOutput, final boolean showError,
    final String outputFilePath, final String errorFilePath) {
    super(projectDir, task, showOutput, showError, outputFilePath, errorFilePath)
  }

  @Override
  void run() {
    final connection = createNewConnetion()
    try {
      arrangeStreams()
      buildLauncher(connection).run()
    } finally {
      connection.close()
      closeStreams()
    }
  }
}

class SimultaneousTask extends ConcurrentTask {
  @Inject
  SimultaneousTask(final WorkerExecutor workerExecutor) {
    super(workerExecutor, SimultaneousTaskUnitOfWork)
  }
}

task concurrentClasses(type: ScheduledEndlessTask) {
  // ScheduledEndlessTask task settings
  projectDir = project.projectDir.absolutePath
  task = 'classes'
  extraParams = [10000, true]
  outputFilePath = "$project.buildDir/concurrentClasses.out"
  errorFilePath = "$project.buildDir/concurrentClasses.err"
  showOutput = true
  // gradle task settings
  description = 'Runs a concurrent classes task.'
  group = BACK$GROUP_RUN
}

task concurrentBootRun(type: SimultaneousTask) {
  // SimultaneousTask task settings
  projectDir = project.projectDir.absolutePath
  task = 'monitorRun'
  showOutput = true
  showError = true
  // gradle task settings
  description = 'Runs a concurrent monitorRun task.'
  group = BACK$GROUP_RUN
}

task hotRun {
  description = 'Runs the project with support for monitoring and reloading classes and static resources.'
  group = BACK$GROUP_RUN
  dependsOn = ['concurrentBootRun', 'concurrentClasses']
}
